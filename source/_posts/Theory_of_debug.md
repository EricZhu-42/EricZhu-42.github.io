---
title: Theory of Debug
date: 2019-11-08
tags: [Lecture Notes]
---

# 调试：理论与实践

> 本文的主要来自[JYY老师](http://ics.nju.edu.cn/~jyy/)的[ICS2019课程](http://ics.nju.edu.cn/~jyywiki/wiki/ICS2019)讲义

## 在讲理论之前的箴言

- 机器永远是对的
- 未测试代码永远是错的

## 为什么Debug那么困难？

因为 bug 的触发经历了漫长的过程：
Fault (bug) → Error (程序状态错) → Failure (可观测的结果错)

- 我们只能观测到 failure
- 我们可以检查状态的正确性 (但非常费时)
- 无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)

![img](/Theory_of_debug/fault-error-failure.png)

## 调试理论

首先，我们必须知道，程序/系统是一个**状态机**。

###  理论中的调试

> 如果我们能**判定**（由需求确定）任意程序状态的正确性，那么给定一个 failure，我们可以通过**二分查找**定位到第一个 error 的状态，此时的代码就是 fault (bug)。 

因此，调试循环中的（如高斯消元，动态规划问题）中的bug往往会比较困难。

### 实际中的调试

 这个理论有一个非常明显的**缺陷**：对 OJ 题之类的小程序还行，对于一个软件、大程序，根本没法用，因此有推论 ：

> 通过观察程序执行的轨迹 (trace)，缩小错误状态 (error) 可能产生的位置，从而定位到 bugs.
> - print → 自定义 log 的 trace
> - gdb → 指令/语句级 trace

实际上，我们难以确定每一个程序状态是否正确。因此，我们常常在调试时，每间隔一段语句块输出当前的程序状态（如print），判断当前的程序状态是否正确。

### print vs gdb

#### print (logs)

- Pros: 灵活可控、能快速定位问题大概位置、适用于大型软件
- Cons: 无法精确定位、大量的 logs 管理起来比较麻烦

#### gdb

- Pros: 精确、指令级定位、任意查看程序内部状态
- Cons: 耗时

#### 实际使用

- debug 业务逻辑时一般使用 log
- debug 具体 root cause 的时候一般用 gdb


##  调试 (不是一般意义上 “程序” 的) bug 

问题诊断其实也是调试，应该利用调试理论去解决问题。

UNIX 世界里你做任何事情都是在编程

- 因此配置错、make 错等，都是程序或输入/配置有 bug
- (输入/配置可以看成是程序的一部分)

刚才的例子

- 没有 “原因报告” (或原因报告不准) → 抓瞎
- 我们需要更详细的程序执行过程 (log) → 既然我们有需求，那别人肯定也会有这个需求 → 肯定已经有人搞定这个了

### 使用调试理论

正确的方法：理解程序的执行过程，弄清楚到底为何导致了bug

- `ssh`：使用 `-v` 选项检查日志

- `gcc`：使用 `-v` 选项打印各种过程

- `make`：使用 `-n` 选项查看完整命令

## 调试程序代码

在调试过程中，我们希望Fault能尽快触发Error，Error能尽快触发Failure.

- 通过测试（CPUtest等）让Fault触发Error
- 通过Differential Test、**Assert**让Error触发Failure

#### 启发：输出什么调试信息？

定位出错点、向前追踪都既需要底层详细的调试信息 (用于排查具体问题)，也需要高层抽象的调试信息 (用于快速定位)

所以你需要**不同类型的** logs！

- 能够快速帮你映射到程序执行的总体走势 (function call logs)
- 指令执行的日志 (框架代码已经提供了)
- 更细致的指令检查工具 (PA1 的内容，知道为啥要做 PA1 了吧？)
- 其他有用的信息 (例如 I/O 指令的内容、内存访问的日志等，按需打开)


核心思想：输出足够的信息，在各个层面上理解程序的执行